#!/usr/bin/env python
# coding: utf-8

# Немного магии Python.
# Дан пустой класс IamPass. По условию задачи вам запрещено писать код внутри класса.
# при десятом и более срабатывании атрибута IamPass.get_message() выводится сообщение "Хватит меня вызывать"

# In[48]:
import math


class IamPass:  # Запрещено изменять
    pass


# Тут начинается ваш код
i = 0


def get_message():
    global i
    if i > 10:
        print("Хватит меня вызывать")
    i = i + 1


IamPass.get_message = get_message

# при десятом и более срабатывании метода IamPass.get_message() выводится сообщение "Хватит меня вызывать"

# Тут заканчивается ваш код

# Вот вызов IamPass.get_count() более 10 раз.
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()
IamPass.get_message()

# Написать два варианта реализации факториала.
# 1. Вариант через функцию def
# 2. Вариант через lambda

# In[90]:


fac_l = lambda n: n * fac_l(n - 1) if n > 0 else 1


def fac(n):
    if n < 1:
        return 0

    if n < 9999:
        return fac_l(n)

    f = 1
    for x in range(1, n, 1):
        f += f * x
    return f


print(fac(100))
print(fac_l(100))
print(math.factorial(100))

# Нужно вычислить факториал 100000.

# In[67]:

print(fac(100000))
print(math.factorial(100000))

# Довольно распространённая ошибка ошибка — это повтор слова.
# Вот в предыдущем предложении такая допущена. Необходимо исправить каждый такой повтор
# (слово, один или несколько пробельных символов, и снова то же слово).
#
# Ввод:
# Довольно распространённая ошибка ошибка — это лишний повтор повтор слова слова.
# Смешно, не не правда ли? Не нужно портить хор хоровод.
#
# Вывод:
# Довольно распространённая ошибка — это лишний повтор слова. Смешно, не правда ли? Не нужно портить хор хоровод.

# In[95]:

ts = 'Довольно распространённая ошибка ошибка — это лишний повтор повтор слова слова. ' \
     'Смешно, не не правда ли? Не нужно портить хор хоровод.'
nts = ""

buf = ""
for word in ts.split(" "):
    if buf != word:
        nts += word + " "
        buf = word

print(nts)

# Хайку — жанр традиционной японской лирической поэзии века, известный с XIV века.
# Оригинальное японское хайку состоит из 17 слогов, составляющих один столбец иероглифов.
# Особыми разделительными словами — кирэдзи — текст хайку делится на части из 5, 7 и снова 5 слогов.
# При переводе хайку на западные языки традиционно вместо разделительного слова использую разрыв строки и,
# таким образом, хайку записываются как трёхстишия.
#
#
# Перед вами трёхстишия, которые претендуют на то, чтобы быть хайку.
# В качестве разделителя строк используются символы / . Если разделители делят текст на строки,
# в которых 5/7/5 слогов, то выведите «Хайку!».
# Если число строк не равно 3, то выведите строку «Не хайку. Должно быть 3 строки.»
# Иначе выведите строку вида «Не хайку. В i строке слогов не s, а j.»,
# где строка i — самая ранняя, в которой количество слогов неправильное.
#
#
# Для простоты будем считать, что слогов ровно столько же, сколько гласных, не задумываясь о тонкостях.
#
# Ввод |	                                                             Вывод
# ---|---
# Вечер за окном. / Еще один день прожит. / Жизнь скоротечна... 	     | Хайку!
# Просто текст 	                                                         | Не хайку. Должно быть 3 строки.
# Как вишня расцвела! / Она с коня согнала / И князя-гордеца. 	         | Не хайку. В 1 строке слогов не 5, а 6.
# На голой ветке / Ворон сидит одиноко… / Осенний вечер! 	             | Не хайку. В 2 строке слогов не 7, а 8.
# Тихо, тихо ползи, / Улитка, по склону Фудзи, / Вверх, до самых высот!  | Не хайку. В 1 строке слогов не 5, а 6.
# Жизнь скоротечна… / Думает ли об этом / Маленький мальчик. 	         | Хайку!

# In[ ]:

t1 = 'Вечер за окном. / Еще один день прожит. / Жизнь скоротечна...'
t2 = 'Просто текст'
t3 = 'Как вишня расцвела! / Она с коня согнала / И князя-гордеца.'
t4 = 'На голой ветке / Ворон сидит одиноко… / Осенний вечер!'
t5 = 'Тихо, тихо ползи, / Улитка, по склону Фудзи, / Вверх, до самых высот!'
t6 = 'Жизнь скоротечна… / Думает ли об этом / Маленький мальчик.'


def is_haiku(t: str):
    texts = t.split(" / ")
    if len(texts) != 3:
        return "Не хайку. Должно быть 3 строки."

    text_switcher = [5, 7, 5]

    for text_it in range(len(texts)):
        letter_count = 0
        for letter in texts[text_it]:
            if letter.lower() in ['а', 'о', 'и', 'е', 'ё', 'э', 'ы', 'у', 'ю', 'я']:
                letter_count += 1
        if text_switcher[text_it] != letter_count:
            return f"Не хайку. В {text_it} строке слогов не {text_switcher[text_it]}, а {letter_count}."

    return "Хайку!"


print(is_haiku(t1))
print(is_haiku(t2))
print(is_haiku(t3))
print(is_haiku(t4))
print(is_haiku(t5))
print(is_haiku(t6))


# Для чего служит ключевое слово «self»?
# Ссылка на сам объект
class A:
    def __init__(self):
        self.x = 5

    def add(self, x):
        self.x += x


# Для чего служит ключевое слово «yield»?
# return для генератора
def create_generator(n):
    my_list = range(n)
    for x in my_list:
        yield x * x


for i in create_generator(5):
    print(i)
